'---Script created on 04-25-2020 20:39:06 by
'uses "console"
Uses "TBGL"
Uses "UI"

#include "gameZoneDefinition.tbasicu"

  Type tRiver
      minSectorSurface as dWord
      minHalfWidth as byte
      maxHalfWidth as byte
      banksWidth as byte
      seed as Number
End Type

  Type tXY
      x as DWORD
      y as DWORD
End Type

' To store flow direction in waypoints
  begin Const '
  %NORTH         = 1
  %SOUTH         = 2
  %EAST          = 4
  %WEST         = 8
  end const

Function TBMain()

  call parametersSetting ' Sets initial variables
  Call initDisplay ' Create the windows for map display
  Call initWorldMap ' Build straight river
  Call stirWorldMap
  CAll sleepDisplay ' Final loop to keep displaying map

End Function

function parametersSetting()

  global displayWindowSize as tXY
  global hWnd AS DWORD

  global myRiver as tRiver
  Global actualRiverStatus as tRiver

  myRiver.banksWidth = 3
  myRiver.minHalfWidth = 1
  myRiver.maxHalfWidth = 5 ' typical = 3 to 12
  myRiver.minSectorSurface = 100 * myRiver.maxHalfWidth
  myRiver.seed = 71250831 ' try different values ' 23031

  global mapDimensions as tXY

  for i as byte = myRiver.minHalfWidth to myRiver.maxHalfWidth
    mapDimensions.y += Fix(myRiver.minSectorSurface/i^0.5)
  next i

  mapDimensions.x = fix(mapDimensions.y / 4)

  global actualPosition as tXY

  actualPosition.y = 0
  actualPosition.x = fix(mapDimensions.x / 2)

  global map as tGameZoneDefinition()

  MsgBox 0, mapDimensions.x & " x " & mapDimensions.y , , "mapDimensions"

End Function

function initDisplay()

  DESKTOP GET CLIENT TO displayWindowSize.x, displayWindowSize.y

' why (-15) ?
  hWnd = tbgl_CreateWindowEx("press ESC to quit", min(mapDimensions.x, displayWindowSize.x / 2), min(mapDimensions.y, displayWindowSize.y), 32, %tbgl_WS_WINDOWED or %tbgl_WS_CLOSEBOX, -15 + displayWindowSize.x - min(mapDimensions.x, displayWindowSize.x / 2), 0)
  tbgl_ShowWindow
  tbgl_ResetKeyState()

End Function

function initWorldMap()

  for i as byte = myRiver.minHalfWidth to myRiver.maxHalfWidth
    actualRiverStatus.minHalfWidth = i
    for j as dword = 1 to Fix(myRiver.minSectorSurface/i^0.5)
      actualPosition.y += 1
      widen2
    next j
    drawing
  next i
  
  ' Drawing a square 
  ' if map dimensions .y is < screen vertical resolution then
  ' the square is square ( for myRiver.maxHalfWidth = 3 or 4 )
  ' else it is squashed ( for myRiver.maxHalfWidth = 5 to 12 )
  ' could be fun to render to a scaled picture
  
  widen(10,10,150,150)
  widen(280,500,300,1000)
  drawing
  
End Function

Function widen2()

  for u as Long = (actualPosition.x - actualRiverStatus.minHalfWidth) to (actualPosition.x + actualRiverStatus.minHalfWidth)
    map.addGameZone(u, actualposition.y)
  next

End Function

function stirWorldMap()

  Randomize(myRiver.seed)

  Local longitude, latitude as DWord

  latitude = RND(myRiver.maxHalfWidth, mapDimensions.y - myRiver.maxHalfWidth)
  longitude = rnd(myRiver.maxHalfWidth, mapDimensions.x - myRiver.maxHalfWidth)
  crossMap(%EAST, latitude)
  drawing
  
  'Limited demo
  
  For barr as byte = 1 to 5 
    For foo as byte = 1 to 2
      latitude = RND(myRiver.maxHalfWidth, mapDimensions.y - myRiver.maxHalfWidth)
      crossMap(%WEST, latitude)
      drawing
    next foo
    For foo as byte = 1 to 2
      latitude = RND(myRiver.maxHalfWidth, mapDimensions.y - myRiver.maxHalfWidth)
      crossMap(%EAST, latitude)
      drawing
    next foo
  next barr
  MsgBox 0, "Done"

End Function

Function crossMap(toWhere as byte, borderPosition as DWord)

  local isCrossing as byte
  Local maxLarge as Byte = 1 + myRiver.maxHalfWidth * 2
  Local fromTo, startPosition as tXY
  Local minStretchLength, maxExpandPlace, actualExpand, fromToSelectSize, positionSelection, positionOffset as DWord

  select case toWhere
    case %EAST

      for i as DWord = 1 to mapDimensions.x

        if map.isGameZone(i, borderPosition) Then
        
          incr isCrossing
          
        elseif isCrossing > 0 Then
        
          if isCrossing > maxLarge Then
            isCrossing = 0
            Iterate for
          endif


          startPosition.x = i
          startPosition.y = borderPosition
            
          getStretchLength(toWhere, startPosition, isCrossing, fromTo)

          minStretchLength = 2 + isCrossing * 2 + myRiver.banksWidth * 4
          
          if fromTo.y - fromTo.x >= minStretchLength Then
          
            fromToSelectSize = rnd(minStretchLength, Max(minStretchLength, Fix( 0.9 * (fromTo.y - fromTo.x - myRiver.banksWidth * 4))))
            'printl "minStretchLength: " , minStretchLength , "select size: ", fromToSelectSize, "out of : ", str$(fromTo.y - fromTo.x)
            positionSelection = (fromTo.y - fromTo.x - fromToSelectSize)
            
            positionOffset = rnd(myRiver.banksWidth * 4, fix(PositionSelection/2))
            
            fromTo.x += positionOffset
            fromTo.y = fromTo.x + fromToSelectSize

            maxExpandPlace = getExpandPlace(toWhere, fromTo, startPosition, isCrossing)

            if maxExpandPlace < startPosition.x - isCrossing - 1 - 2 * myRiver.banksWidth Then
            
              actualExpand = fix(0.15 * (startPosition.x - isCrossing - 1 - maxExpandPlace))

              maxExpandPlace = rnd(maxExpandPlace + actualExpand, startPosition.x - isCrossing - 1 - actualExpand)
             
              widen(maxExpandPlace , fromTo.x, maxExpandPlace + isCrossing - 1, fromTo.y) ' (XNW as DWord, YNW as DWord, XSE as DWord, YSE as DWord)
              widen(maxExpandPlace + isCrossing, fromTo.y - isCrossing + 1 , startPosition.x - isCrossing - 1 , fromTo.y )
              widen(maxExpandPlace + isCrossing, fromTo.x, startPosition.x - isCrossing - 1 , fromTo.x + isCrossing )
              refund(startPosition.x - isCrossing - 1, fromTo.x + isCrossing + 1, startPosition.x - 1, fromTo.y - isCrossing)

            End If
          endif
        isCrossing = 0
        endif
        
      Next

    case %WEST
    
    for i as DWord = mapDimensions.x to 1 step -1

        if map.isGameZone(i, borderPosition) Then
        
          incr isCrossing
          
        elseif isCrossing > 0 Then
        
          if isCrossing > maxLarge Then
            isCrossing = 0
            Iterate for
          endif

          startPosition.x = i
          startPosition.y = borderPosition
            
          getStretchLength(toWhere, startPosition, isCrossing, fromTo)

          minStretchLength = 2 + isCrossing * 2 + myRiver.banksWidth * 4
          
          if fromTo.y - fromTo.x >= minStretchLength Then
          
            fromToSelectSize = rnd(minStretchLength, Max(minStretchLength, Fix( 0.9 * (fromTo.y - fromTo.x - myRiver.banksWidth * 4))))
            
            positionSelection = (fromTo.y - fromTo.x - fromToSelectSize)
            
            positionOffset = rnd(myRiver.banksWidth * 4, fix(PositionSelection/2))
            
            fromTo.x += positionOffset
            fromTo.y = fromTo.x + fromToSelectSize

            maxExpandPlace = getExpandPlace(toWhere, fromTo, startPosition, isCrossing)

            if maxExpandPlace > startPosition.x + isCrossing + 1 + 2 * myRiver.banksWidth Then
            
            actualExpand = fix(0.15 * (maxExpandPlace - startPosition.x + isCrossing + 1))

            maxExpandPlace = rnd(maxExpandPlace - actualExpand, startPosition.x + isCrossing + 1 + actualExpand)
             
              widen(maxExpandPlace - isCrossing + 1, fromTo.x, maxExpandPlace, fromTo.y) ' (XNW as DWord, YNW as DWord, XSE as DWord, YSE as DWord)
              widen(startPosition.x + isCrossing + 1, fromTo.y - isCrossing + 1 , maxExpandPlace - isCrossing , fromTo.y )
              widen(startPosition.x + isCrossing + 1, fromTo.x, maxExpandPlace - isCrossing , fromTo.x + isCrossing )
              refund(startPosition.x +1, fromTo.x + isCrossing + 1, startPosition.x + 1 + isCrossing, fromTo.y - isCrossing)
            End If
          endif
        isCrossing = 0
        endif
        
      Next

    Case %NORTH
    Case %SOUTH

  end select
End Function


Function getExpandPlace(toWhere as Byte, fromTo as tXY, startPosition as tXY, isCrossing as Byte) as DWord
    select case toWhere
    case %EAST
    
    for i as DWord = startPosition.x - myRiver.banksWidth - isCrossing to 1 step -1 ' 
    	for j as dword = fromTo.x - myRiver.banksWidth to fromTo.y + myRiver.banksWidth
        if map.isGameZone(i, j) Then
          return i + 2 * myRiver.banksWidth
        endif
    	Next
    Next
    
    return 2 * myRiver.banksWidth
    
    case %WEST
    
    for i as DWord = startPosition.x + myRiver.banksWidth + isCrossing to mapDimensions.x
    	for j as dword = fromTo.x - myRiver.banksWidth to fromTo.y + myRiver.banksWidth
        if map.isGameZone(i, j) Then
          return i - 2 * myRiver.banksWidth
        endif
    	Next
    Next
    
    return mapDimensions.x - 2 * myRiver.banksWidth

    Case %NORTH
    Case %SOUTH

  end select
End Function

Function getStretchLength(toWhere as BYTE, startPosition as tXY, stretchWidth as Byte, byref stretchLength as tXY)

  Local leftRight1, leftRight2, leftRight3, leftRight4 as DWord

  select case toWhere
    case %EAST

      for i as dword = startPosition.y to 1 step -1

        if map.isGameZone(startPosition.x, i) and leftRight1 = 0 Then
          leftRight1 = i + 1
          exit for
        End If
        if map.isGameZone(startPosition.x - 1, i) = 0 and leftRight2 = 0 Then
          leftRight2 = i + 1
          exit for
        End If
        if map.isGameZone(startPosition.x - stretchWidth, i) = 0 and leftRight3 = 0 Then
          leftRight3 = i + 1
          exit for
        End If
        if map.isGameZone(startPosition.x - stretchWidth - 1, i) and leftRight4 = 0 Then
          leftRight4 = i + 1
          exit for
        End If
        
      Next

      stretchLength.x = max(leftRight1, leftRight2, leftRight3, leftRight4)
   
      leftRight1 = mapDimensions.y
      leftRight2 = mapDimensions.y
      leftRight3 = mapDimensions.y
      leftRight4 = mapDimensions.y

      For i as Dword = startPosition.y To mapDimensions.y

        if map.isGameZone(startPosition.x, i) and leftRight1 = mapDimensions.y Then
          leftRight1 = i - 1
          exit for
        End If
        if map.isGameZone(startPosition.x - 1, i) = 0 and leftRight2 = mapDimensions.y Then
          leftRight2 = i - 1
          exit for
        End If
        if map.isGameZone(startPosition.x - stretchWidth, i) = 0 and leftRight3 = mapDimensions.y Then
          leftRight3 = i - 1
          exit for
        End If
        if map.isGameZone(startPosition.x - stretchWidth - 1, i) and leftRight4 = mapDimensions.y Then
          leftRight4 = i - 1
          Exit for
        End If

      Next

      stretchLength.y = min(leftRight1, leftRight2, leftRight3, leftRight4)

    case %WEST

      for i as dword = startPosition.y to 1 step -1

        if map.isGameZone(startPosition.x, i) and leftRight1 = 0 Then
          leftRight1 = i + 1
          Exit for
        End If
        if map.isGameZone(startPosition.x + 1, i) = 0 and leftRight2 = 0 Then
          leftRight2 = i + 1
          Exit for
        End If
        if map.isGameZone(startPosition.x + stretchWidth, i) = 0 and leftRight3 = 0 Then
          leftRight3 = i + 1
          Exit for
        End If
        if map.isGameZone(startPosition.x + stretchWidth + 1, i) and leftRight4 = 0 Then
          leftRight4 = i + 1
          Exit for
        End If

      Next

      stretchLength.x = max(leftRight1, leftRight2, leftRight3, leftRight4)
   
      leftRight1 = mapDimensions.y
      leftRight2 = mapDimensions.y
      leftRight3 = mapDimensions.y
      leftRight4 = mapDimensions.y

      For i as Dword = startPosition.y To mapDimensions.y

      if map.isGameZone(startPosition.x, i) and leftRight1 = mapDimensions.y Then
          leftRight1 = i - 1
          Exit for
        End If
        if map.isGameZone(startPosition.x + 1, i) = 0 and leftRight2 = mapDimensions.y Then
          leftRight2 = i - 1
          Exit for
        End If
        if map.isGameZone(startPosition.x + stretchWidth, i) = 0 and leftRight3 = mapDimensions.y Then
          leftRight3 = i - 1
          Exit for
        End If
        if map.isGameZone(startPosition.x + stretchWidth + 1, i) and leftRight4 = mapDimensions.y Then
          leftRight4 = i - 1
          Exit for
        End If

      Next

      stretchLength.y = min(leftRight1, leftRight2, leftRight3, leftRight4)
      
    Case %NORTH
    Case %SOUTH

  end select

End Function

function sleepDisplay()

' -- Main loop
  While tbgl_IsWindow(hWnd)
    call drawing
' -- ESCAPE key to exit application
    If tbgl_GetWindowKeyState(hWnd, %VK_ESCAPE) Then Exit While
  Wend

  tbgl_DestroyWindow

End Function

Function drawing()

' -- Set the resolution and the coordinate system
  tbgl_Rendermatrix2D (0,mapDimensions.y, mapDimensions.x,0)
  tbgl_ClearFrame

' -- Draw river map
  map.Render()

'Show the rendered stuff to the public :)
  tbgl_DrawFrame

End Function

function widen(XNW as DWord, YNW as DWord, XSE as DWord, YSE as DWord)

  for u as Long = YNW to YSE
    for v as Long = XNW to XSE
      if not map.isGameZone(v,u) then map.addGameZone(v,u)
    next
  next

  'map.addWaypoint(actualPosition.x+1, actualPosition.y+1)

End Function

function refund(XNW as DWord, YNW as DWord, XSE as DWord, YSE as DWord)

  for u as Long = YNW to YSE
    for v as Long = XNW to XSE
      if map.isGameZone(v,u) then map.removeGameZone(v,u)
    next
  next

End Function


function isDirectionSet(compass as long, direction as long) as long
  return bit_get(compass, log2(direction))
end function

Function bitCount(Storage as Long) as Long
  Return Tally(bin$(Storage), "1")
End Function
