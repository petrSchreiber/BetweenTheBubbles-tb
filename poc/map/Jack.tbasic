
uses "console"
Uses "TBGL"
Uses "UI"

#include "init.tbasicu"
#include "gameZoneDefinition.tbasicu"
#Include "https://github.com/DirectuX/logger/raw/master/LOG.tbasicu"

Global logger as tLogThis
logger.defaultTarget = %LT_ToConsole
Console_SetOutputCP(%CP_UTF8)
Console_SetScreenBufferSize(120,300) ' /!\ No way to set the console window width, or shrink font size ?
Console_ShowWindow(%Console_SW_SHOWMAXIMIZED)


  type tBtbuniverse
  worldList(%WORLDCOUNT) as tBtbworld
  squareLimitsRatio as DWord
  worldCount as DWord
  
  
  Function _Create()
    dim tempArray() as dword
    Dim tempDataCount as DWord
    Dim prepareFunction as String
    Dim isSuccess as Boolean
    Dim previousLevel as DWord
    
    Dim equalWidth as DWord
    dim splitWidthValue1, splitWidthValue2, splitArmValue1, splitArmValue2 as Single
    Dim distributedBase as Single
    Dim distributedTotal as dword
    Dim narrowCount, narrowTotal, narrowCurrent as DWord
    Dim wideTotal as dword
    
    Dim minimumWorldSideSize as DWord
    Dim worldSizes(%WORLDCOUNT) as dword
    Dim maxSizeIndex as dword = 1
    Dim actualSide as Dword
    DIm bottomLeft as DWord
    Dim bottomRight as Dword
    Dim mapCentreX as Dword
    

#Region "Load init data"

    me.worldCount = %WORLDCOUNT
    
    if me.worldCount < 2 Then
      logger.wCrit("%WORLDCOUNT = " & str$(me.worldCount) & " does not meet requirement. Minimum = 2.")
    	logger.wCrit("Terminating execution... Please, press a key.")
      Waitkey
      stop
    End If
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
    logger.wInfo("Registering " & me.worldCount & " worlds...")
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)

    me.squareLimitsRatio = %SQUARELIMITSRATIO
    
    tempDataCount = loadData($WORLDSSEQUENCE, tempArray)
    
    if tempDataCount = me.worldCount Then
      For i as Integer = 1 to me.worldCount
        prepareFunction = "setAmbiance#" & Format$(tempArray(i),"000")
        Call_IfExists prepareFunction(me.worldList(i).ambiance) to isSuccess
        if not isSuccess Then
          logger.wCrit("Function " & prepareFunction & " has an error or does not exists")
          logger.wCrit("Terminating execution... Please, press a key.")
          Waitkey
          stop
        Else
          logger.wInfo("World №" & i & " ambiance set to " & me.worldList(i).ambiance.gameZoneStyling)
          isSuccess = %FALSE
        endif
      Next
    Else
      logger.wCrit("$WORLDSSEQUENCE data count does not match %WORLDCOUNT.")
      logger.wCrit("Terminating execution... Please, press a key.")
      Waitkey
      stop
    EndIf
    
    tempDataCount = loadData($MINIMUMTOTALRIVERWIDTH, tempArray)
  
    if tempDataCount = me.worldCount Then
      for i as DWord = 1 to me.worldCount
          me.worldList(i).minimumTotalRiverWidth = tempArray(i)
          if me.worldList(i).minimumTotalRiverWidth < 3 * me.worldList(i).ambiance.riverArmsCount Then
          	logger.wCrit("$MINIMUMTOTALRIVERWIDTH for world №" & i & " is insufficient." )
          	logger.wCrit("Value is: " & me.worldList(i).minimumTotalRiverWidth & $Tab & "Minimal is: 3 * " & me.worldList(i).ambiance.riverArmsCount & " = " & Str$(3 * me.worldList(i).ambiance.riverArmsCount))
            logger.wCrit("Terminating execution... Please, press a key.")
            Waitkey
            stop
          End If
          if iseven(me.worldList(i).minimumTotalRiverWidth) then
          	incr me.worldList(i).minimumTotalRiverWidth
          End If
      Next
    Else
      logger.wCrit("$MINIMUMTOTALRIVERWIDTH data count does not match %WORLDCOUNT.")
      logger.wCrit("Terminating execution... Please, press a key.")
      Waitkey
      stop
    EndIf
    
    tempDataCount = loadData($WORLDLEVEL, tempArray)
    
    if tempDataCount = me.worldCount Then
      For i as Integer = 1 to me.worldCount
        if tempArray(i) = previousLevel or tempArray(i) = previousLevel + 1 Then
          if tempArray(i) = previousLevel + 1 and (me.worldList(i).ambiance.hidden <> %VISIBLE or me.worldList(i).ambiance.deadEnd <> %ONMAINSTREAM) Then
            logger.wCrit("First world of each level must be visible and on main stream.")
            logger.wCrit("Terminating execution... Please, press a key.")
          endif
          me.worldList(i).level = tempArray(i)
          previousLevel = tempArray(i)
        Else
          logger.wCrit("$WORLDLEVEL data must contain consecutive numbers.")
          logger.wCrit("Terminating execution... Please, press a key.")
          Waitkey
          stop
        endif
      next
    Else
      logger.wCrit("$WORLDLEVEL data count does not match %WORLDCOUNT.")
      logger.wCrit("Terminating execution... Please, press a key.")
      Waitkey
      stop
    EndIf
    
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
    logger.wInfo("Sucessfully registered " & me.worldCount & " worlds in " & previousLevel & " levels.")
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
  
#EndRegion

logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
logger.wInfo("Setting river properties...")
logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
    

#Region "River properties"
'
'  for i as Integer = 1 to me.worldCount
'  
'    
'    If i < me.worldCount Then
'      me.worldList(i).streamsOutCount = min(me.worldList(i+1).ambiance.riverArmsCount, me.worldList(i).ambiance.riverArmsCount)
'    endif
'    
'    if me.worldList(i).ambiance.riverArmsCount = 1 then me.worldList(i).ambiance.riverArmWidthDistribution = %EQUAL
'  
'    select case me.worldList(i).ambiance.riverArmWidthDistribution
'    
'    	Case %EQUAL
'    	
'        if me.worldList(i).ambiance.riverArmsCount = 1 Then
'          equalWidth = me.worldList(i).minimumTotalRiverWidth
'        else
'          equalWidth = 1 + 2 * Ceil(((me.worldList(i).minimumTotalRiverWidth - me.worldList(i).ambiance.riverArmsCount)/me.worldList(i).ambiance.riverArmsCount)/2)
'        endif
'        me.worldList(i).widestArmWidth = equalWidth
'        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
'          'Width
'          me.worldList(i).arms(j).width = equalWidth
'          'Random depth profile
'          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
'        Next
'        
'    	Case %SPLIT
'        
'        splitWidthValue1 = me.worldList(i).minimumTotalRiverWidth / max(me.worldList(i).ambiance.riverArmsCount, 3)
'        splitWidthValue2 = (max(me.worldList(i).ambiance.riverArmsCount, 3) - 1) * splitWidthValue1
'        splitArmValue1 = me.worldList(i).ambiance.riverArmsCount / 2
'          
'        if splitArmValue1 <> assign(ceil(splitArmValue1), splitArmValue2) then Decr splitArmValue1
'        
'        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
'          'Width
'          if splitArmValue1 > 2 and splitWidthValue1 >=8 then
'            me.worldList(i).arms(j).width = 5
'            splitWidthValue1 -= 5
'            decr splitArmValue1
'            me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
'            Iterate for
'          elseif splitArmValue1 > 0 and splitWidthValue1 >= 3 then
'            me.worldList(i).arms(j).width = 3
'            splitWidthValue1 -= 3
'            decr splitArmValue1
'            me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
'            Iterate for
'          endif
'          
'          splitArmValue1 = 0
'          splitWidthValue2 += splitWidthValue1
'          splitWidthValue1 = 0
'            
'          if splitArmValue2 = 1 Then
'          	me.worldList(i).arms(j).width = 1 + 2 * ceil(splitWidthValue2 / 2)
'          	me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
'          	Iterate for
'          Else
'            me.worldList(i).arms(j).width = 1 + 2 * ceil((splitWidthValue2 - splitArmValue2) / splitArmValue2) / 2
'          End If
'          
'          me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
'          
'          'Random depth profile
'          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
'        Next
'        
'    	Case %DISTRIBUTED
'    	
'    	distributedBase = (me.worldList(i).minimumTotalRiverWidth /(( me.worldList(i).ambiance.riverArmsCount + 1 ) / 2)) / me.worldList(i).ambiance.riverArmsCount
'    	distributedTotal = 0
'
'      for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
'        'Width
'        if j = me.worldList(i).ambiance.riverArmsCount Then
'          me.worldList(i).arms(j).width += iseven(assign(me.worldList(i).minimumTotalRiverWidth - distributedTotal, me.worldList(i).arms(j).width))
'        Else
'          me.worldList(i).arms(j).width += iseven(assign(Round(distributedBase * j,0),me.worldList(i).arms(j).width))
'          distributedTotal += me.worldList(i).arms(j).width
'        endif
'        
'        me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
'        
'        'Random depth profile
'        me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
'      Next
'        
'    	Case %MOSTLYNARROW
'    	
'        narrowCount = 0
'        narrowCurrent = 3
'        narrowTotal = 0
'        
'        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
'          incr narrowCount
'          if narrowCount > 3 then
'          	narrowCount = 0
'          	narrowCurrent += 2
'          End If
'          'Width
'          if j = me.worldList(i).ambiance.riverArmsCount Then
'            me.worldList(i).arms(j).width += iseven(assign(me.worldList(i).minimumTotalRiverWidth - narrowTotal, me.worldList(i).arms(j).width))
'          else
'            me.worldList(i).arms(j).width = narrowCurrent
'            narrowTotal += narrowCurrent
'          endif
'          
'          me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
'          
'          'Random depth profile
'          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
'        Next
'        
'    	Case %MOSTLYWIDE
'    	
'        wideTotal = 0
'        
'        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
'          'Width
'          if j = me.worldList(i).ambiance.riverArmsCount Then
'            me.worldList(i).arms(j).width += iseven(assign(me.worldList(i).minimumTotalRiverWidth - wideTotal, me.worldList(i).arms(j).width))
'          Else
'            me.worldList(i).arms(j).width += iseven(assign(ceil(me.worldList(i).minimumTotalRiverWidth / (me.worldList(i).ambiance.riverArmsCount + j - 1)), me.worldList(i).arms(j).width))
'            wideTotal += me.worldList(i).arms(j).width
'          endif
'          
'          me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
'          
'          'Random depth profile
'          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
'        Next
'        
'    End Select
'    
'    '[todo] <Something to do here>
'    ' Here sorting me.worldList(i).arms(j).width wide to narrow ; how array sort ?
'   #Region " Sort arms by width descending"
'    Dim sorted as Boolean
'    DIm tempArm as tArm
'      '[breakpoint] <Any note here. Breakpoint will be set to line following this statement>
'    Do
'      sorted = %TRUE
'      for j = 2 to me.worldList(i).ambiance.riverArmsCount
'        if me.worldList(i).arms(j).width > me.worldList(i).arms(j-1).width Then
'        	sorted = %False
'        	tempArm = me.worldList(i).arms(j).width
'        	me.worldList(i).arms(j-1).width = me.worldList(i).arms(j).width
'        	me.worldList(i).arms(j).width = tempArm
'        End If
'      Next
'    loop until sorted = %TRUE
'   #EndRegion 
'  Next
'  
#EndRegion


#Region "Workaround version River properties"

  for i as Integer = 1 to me.worldCount
    
    If i < me.worldCount Then
      me.worldList(i).streamsOutCount = min(me.worldList(i+1).ambiance.riverArmsCount, me.worldList(i).ambiance.riverArmsCount)
    endif
    
    if me.worldList(i).ambiance.riverArmsCount = 1 then me.worldList(i).ambiance.riverArmWidthDistribution = %EQUAL
  
    select case me.worldList(i).ambiance.riverArmWidthDistribution
    
    	Case %EQUAL
    	
        if me.worldList(i).ambiance.riverArmsCount = 1 Then
          equalWidth = me.worldList(i).minimumTotalRiverWidth
        else
          equalWidth = 1 + 2 * Ceil(((me.worldList(i).minimumTotalRiverWidth - me.worldList(i).ambiance.riverArmsCount)/me.worldList(i).ambiance.riverArmsCount)/2)
        endif
        me.worldList(i).widestArmWidth = equalWidth
        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
          'Width
          me.worldList(i).arms(j).width = equalWidth
          'Random depth profile
          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
        Next
        
    	Case %SPLIT
        
        splitWidthValue1 = me.worldList(i).minimumTotalRiverWidth / max(me.worldList(i).ambiance.riverArmsCount, 3)
        splitWidthValue2 = (max(me.worldList(i).ambiance.riverArmsCount, 3) - 1) * splitWidthValue1
        splitArmValue1 = me.worldList(i).ambiance.riverArmsCount / 2
          
        if splitArmValue1 <> assign(ceil(splitArmValue1), splitArmValue2) then Decr splitArmValue1
        
        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
          'Width
          if splitArmValue1 > 2 and splitWidthValue1 >=8 then
            me.worldList(i).arms(j).width = 5
            splitWidthValue1 -= 5
            decr splitArmValue1
            me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
            Iterate for
          elseif splitArmValue1 > 0 and splitWidthValue1 >= 3 then
            me.worldList(i).arms(j).width = 3
            splitWidthValue1 -= 3
            decr splitArmValue1
            me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
            Iterate for
          endif
          
          splitArmValue1 = 0
          splitWidthValue2 += splitWidthValue1
          splitWidthValue1 = 0
            
          if splitArmValue2 = 1 Then
          	me.worldList(i).arms(j).width = 1 + 2 * ceil(splitWidthValue2 / 2)
          	me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
          	Iterate for
          Else
            me.worldList(i).arms(j).width = 1 + 2 * ceil((splitWidthValue2 - splitArmValue2) / splitArmValue2) / 2
          End If
          
          me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
          
          'Random depth profile
          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
        Next
        
    	Case %DISTRIBUTED
    	
    	distributedBase = (me.worldList(i).minimumTotalRiverWidth /(( me.worldList(i).ambiance.riverArmsCount + 1 ) / 2)) / me.worldList(i).ambiance.riverArmsCount
    	distributedTotal = 0

      for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
        'Width
        if j = me.worldList(i).ambiance.riverArmsCount Then
          me.worldList(i).arms(j).width += iseven(assign2(me.worldList(i).minimumTotalRiverWidth - distributedTotal, varptr(me.worldList(i).arms(j).width)))
        Else
          me.worldList(i).arms(j).width += iseven(assign2(Round(distributedBase * j,0),varptr(me.worldList(i).arms(j).width)))
          distributedTotal += me.worldList(i).arms(j).width
        endif
        
        me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
        
        'Random depth profile
        me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
      Next
        
    	Case %MOSTLYNARROW
    	
        narrowCount = 0
        narrowCurrent = 3
        narrowTotal = 0
        
        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
          incr narrowCount
          if narrowCount > 3 then
          	narrowCount = 0
          	narrowCurrent += 2
          End If
          'Width
          if j = me.worldList(i).ambiance.riverArmsCount Then
            me.worldList(i).arms(j).width += iseven(assign2(me.worldList(i).minimumTotalRiverWidth - narrowTotal, varptr(me.worldList(i).arms(j).width)))
          else
            me.worldList(i).arms(j).width = narrowCurrent
            narrowTotal += narrowCurrent
          endif
          
          me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
          
          'Random depth profile
          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
        Next
        
    	Case %MOSTLYWIDE
    	
        wideTotal = 0
        
        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
          'Width
          if j = me.worldList(i).ambiance.riverArmsCount Then
            me.worldList(i).arms(j).width += iseven(assign2(me.worldList(i).minimumTotalRiverWidth - wideTotal, varptr(me.worldList(i).arms(j).width)))
          Else
            me.worldList(i).arms(j).width += iseven(assign2(ceil(me.worldList(i).minimumTotalRiverWidth / (me.worldList(i).ambiance.riverArmsCount + j - 1)), varptr(me.worldList(i).arms(j).width)))
            wideTotal += me.worldList(i).arms(j).width
          endif
          
          me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
          
          'Random depth profile
          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
        Next
        
    End Select
    

    '[todo] <Something to do here>
    ' Here sorting me.worldList(i).arms(j).width wide to narrow ; how array sort ?
   #Region " Sort arms by width descending"
    Dim sorted as Boolean
    DIm tempArm as tArm
      '[breakpoint] <Any note here. Breakpoint will be set to line following this statement>
    Do
      sorted = %TRUE
      for j = 2 to me.worldList(i).ambiance.riverArmsCount
        if me.worldList(i).arms(j).width > me.worldList(i).arms(j-1).width Then
        	sorted = %False
        	tempArm = me.worldList(i).arms(j).width
        	me.worldList(i).arms(j-1).width = me.worldList(i).arms(j).width
        	me.worldList(i).arms(j).width = tempArm
        End If
      Next
    loop until sorted = %TRUE
   #EndRegion 
logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
logger.wInfo("Setting river properties...")
logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
  Next
  
#EndRegion

    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
    logger.wInfo("River properties set.")
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)

#Region "Map dimensioning"

    minimumWorldSideSize = 3 + 2 * %BANKSWIDTH
    
    for i as Integer = 1 to me.worldCount
      me.worldList(i).sizeInSquaresCount = minimumWorldSideSize * me.squareLimitsRatio * me.worldList(i).ambiance.relativeSizeWorld

'[t] be careful if more than a 'special' world per mainStream world or special world bigger than parent world
      if me.worldList(i).ambiance.hidden <> %VISIBLE or me.worldList(i).ambiance.deadEnd <> %ONMAINSTREAM then
        worldSizes(i) = me.worldList(i).sizeInSquaresCount + worldSizes(i-1)
      Else
        worldSizes(i) = me.worldList(i).sizeInSquaresCount
      EndIf

      if worldSizes(maxSizeIndex) <= worldSizes(i) Then
        maxSizeIndex = i
      endif
    Next
    
    mapCentreX = worldSizes(maxSizeIndex) + 1
    
    ' First world at left
    me.worldList(1).NWlimit.Y = 1
    me.worldList(1).SElimit.Y = me.worldList(1).sizeInSquaresCount
    bottomLeft = me.worldList(1).SElimit.Y
    
    me.worldList(1).SElimit.X = mapCentreX
    me.worldList(1).NWlimit.X = mapCentreX - me.worldList(1).sizeInSquaresCount
    
    for i as Integer = 2 to me.worldCount
      
      if me.worldList(i).ambiance.hidden <> %VISIBLE or me.worldList(i).ambiance.deadEnd <> %ONMAINSTREAM then
      '[todo] <Something to do here>
        
      Else
          if actualSide = %LEFTSIDE Then
            if bottomLeft > (bottomRight + 2 * %BANKSWIDTH + me.worldList(i-1).widestArmWidth) then
              actualSide = %RIGHTSIDE
            End If
          Else
            if bottomRight > (bottomLeft + 2 * %BANKSWIDTH + me.worldList(i-1).widestArmWidth) then
              actualSide = %LEFTSIDE
            End If
          endif
          
          select case actualSide
          	Case %LEFTSIDE
              me.worldList(i).NWlimit.Y = bottomLeft + 1
              me.worldList(i).SElimit.Y = bottomLeft + me.worldList(i).sizeInSquaresCount
              bottomLeft = me.worldList(i).SElimit.Y
              me.worldList(i).SElimit.X = mapCentreX
              me.worldList(i).NWlimit.X = mapCentreX - me.worldList(i).sizeInSquaresCount
          	Case %RIGHTSIDE
              me.worldList(i).NWlimit.Y = bottomRight + 1
              me.worldList(i).SElimit.Y = bottomRight + me.worldList(i).sizeInSquaresCount
              bottomRight = me.worldList(i).SElimit.Y
              me.worldList(i).SElimit.X = mapCentreX + 1 + me.worldList(i).sizeInSquaresCount
              me.worldList(i).NWlimit.X = mapCentreX + 1
          End Select

      End If
    	
    Next
    
    mapDimensions.X = 2 * worldSizes(maxSizeIndex) + 2
    mapDimensions.Y = max(bottomRight, bottomLeft) + 1
    
    Global map(mapDimensions.X,mapDimensions.Y) as tBtbGameZone
    
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
    logger.wInfo("Map dimmensionned to X: " & str$(mapDimensions.X) & " x Y: " & str$(mapDimensions.Y))
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
    
#Endregion

  
  End Function
end Type



function loadData(sourceString as String, byref storeArray() as dword)
'Local ndata as DWord = PARSECOUNT(sourceString, "")
'redim storeArray(ndata)
  Return Parse(sourceString, storeArray,",")
End Function

Function TBMain()

  logger.defaultTitle = Function_Name
  logger.wInfo("Logger loaded")

  call parametersSetting ' Sets initial variables
  Call initDisplay ' Create the windows for map display
  Call initWorldMap ' Build straight river
  'Call stirWorldMap
  CAll sleepDisplay ' Final loop to keep displaying map

End Function

function parametersSetting()

  logger.defaultTitle = Function_Name

  global displayWindowSize as tXY
  global hWnd AS DWORD
  
  Randomize(%RNDSEED)
  
  Global mapDimensions as TXY
  Global displayWindowSize as tXY
  
  Global btbuniverse as tBtbuniverse

  'For overlay ?
  'Global btblevel as tBtblevel
  Global btbworld as tBtbworld

End Function

Function initWorldMap()

    logger.defaultTitle = Function_Name
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
    logger.wInfo("Now filling map...")

  for i as dword = 1 to btbuniverse.worldCount
    ' set streamStart and streamStop for each arm
    if btbuniverse.worldList(i).ambiance.hidden <> %VISIBLE or btbuniverse.worldList(i).ambiance.deadEnd <> %ONMAINSTREAM then Iterate for 
    ' set world gameZones
    For u as dword = btbuniverse.worldList(i).NWlimit.X to btbuniverse.worldList(i).SElimit.X
    	For v as dword = btbuniverse.worldList(i).NWlimit.Y to btbuniverse.worldList(i).SElimit.Y
        if u = btbuniverse.worldList(i).NWlimit.X or u = btbuniverse.worldList(i).SElimit.X or v = btbuniverse.worldList(i).NWlimit.Y or v = btbuniverse.worldList(i).SElimit.Y Then
          map(u,v).nature = %WORLDLIMIT
        else
          map(u,v).nature = %WORLD
        End If
    	Next
    Next
  Next
  
    logger.wInfo("Mapping done.")
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
  
End Function

function sleepDisplay()

    logger.defaultTitle = Function_Name
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
    logger.wInfo("Drawing...")

    call drawing

    logger.defaultTitle = Function_Name
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
    logger.wInfo("Now sleeping.")
    logger.wInfo("Press ESC. to output picture to file and quit.")

' -- Main loop
  While IsWindow(hWnd)
    call drawing
    
    if asc(Canvas_Inkey)=  27 Then Exit While
  Wend

  Canvas_BitmapSaveImageFile("result.png")
  Canvas_Window end

End Function


Function drawing()

' -- Set the resolution and the coordinate system
  Canvas_Scale pixels'( 1,mapDimensions.y, mapDimensions.x,1)
  Canvas_clear

' -- Draw river map
  for i as dword = 1 to mapDimensions.x
    for j as dword = 1 to mapDimensions.y
      Select case map(i,j).nature
      case %VOID
        Iterate For
      Case %BANK
        Canvas_Color(rgb(64, 255, 128))
      Case %WATER
        Canvas_Color(rgb(64, 128, 255))
      CAse %WORLD
        Canvas_Color(rgb(64, 64, 64))
      CAse %WORLDLIMIT
        Canvas_Color(rgb(32, 32, 32))
      end select
      Canvas_SetPixel(i,j)
    next
  next

'Show the rendered stuff to the public :)
  Canvas_Redraw

End Function

function initDisplay()

  DESKTOP GET CLIENT TO displayWindowSize.x, displayWindowSize.y

  MsgBox 0, str$(displayWindowSize.x) & " x " & str$(displayWindowSize.y),,"Desktop resolution"

  int32 posX   = -15 + displayWindowSize.x - min(mapDimensions.x, displayWindowSize.x / 2)
  int32 posY   = 0
  int32 width  = mapDimensions.x' min(mapDimensions.x, displayWindowSize.x / 2)
  int32 height = mapDimensions.y' min(mapDimensions.y, displayWindowSize.y) + 100

  hWnd = Canvas_Window("press ESC to quit", posX, posY, width, height)
  Canvas_Attach(hWnd, 0, True)

End Function

Function bitCount(storage as Long) as Long
  Return Tally(bin$(Storage), "1")
End Function

function isFlagSet(storage as long, flag as long) as long
  return bit_get(storage, log2(flag))
end function

function getFlag(id as Dword, storage as Long)
  dim i as Long = -1
  do
    incr i
    if isFlagSet(storage, pow(2,i)) Then
      decr id
    endif
  loop while id > 0
  Return Pow(2,i)
End Function

Function getRandomFlag(storage as Long)
  Local randomValue as Long = RND(1,bitCount(storage))
  Return getFlag(randomValue, storage)
End Function

#Region " Part of workaround "
  function Assign2(what as number, where as Number) as number 'error
	dim whereVar as DWord at where
	whereVar = what
  Return whereVar
End Function
#EndRegion

