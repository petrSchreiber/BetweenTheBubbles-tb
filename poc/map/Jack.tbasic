
uses "console"
Uses "TBGL"
Uses "UI"

#include "init.tbasicu"
#include "gameZoneDefinition.tbasicu"
#Include "https://github.com/DirectuX/logger/raw/master/LOG.tbasicu"

Global logger as tLogThis
logger.defaultTarget = %LT_ToConsole
Console_SetOutputCP(%CP_UTF8)
Console_SetScreenBufferSize(120,300) ' /!\ No way to set the console window width, or shrink font size ?
Console_ShowWindow(%Console_SW_SHOWMAXIMIZED)


  type tBtbuniverse
  worldList(%WORLDCOUNT) as tBtbworld
  squareLimitsRatio as DWord
  worldCount as DWord
  
  
  Function _Create()
    dim tempArray() as dword
    Dim tempDataCount as DWord
    Dim prepareFunction as String
    Dim isSuccess as Boolean
    Dim previousLevel as DWord
    
    Dim equalWidth as DWord
    dim splitWidthValue1, splitWidthValue2, splitArmValue1, splitArmValue2 as Single
    Dim distributedBase as Single
    Dim distributedTotal as dword
    Dim narrowCount, narrowTotal, narrowCurrent as DWord
    Dim wideTotal as dword
    
    Dim minimumWorldSideSize as DWord
    Dim worldSizes(%WORLDCOUNT) as dword
    Dim maxSizeIndex as dword = 1
    Dim actualSide as Dword
    DIm bottomLeft as DWord
    Dim bottomRight as Dword
    Dim mapCentreX as Dword
    

#Region "Load init data"

    me.worldCount = %WORLDCOUNT
    
    if me.worldCount < 2 Then
      logger.wCrit("%WORLDCOUNT = " & str$(me.worldCount) & " does not meet requirement. Minimum = 2.")
    	logger.wCrit("Terminating execution... Please, press a key.")
      Waitkey
      stop
    End If
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
    logger.wInfo("Registering " & me.worldCount & " worlds.")
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)

    me.squareLimitsRatio = %SQUARELIMITSRATIO
    
    tempDataCount = loadData($WORLDSSEQUENCE, tempArray)
    
    if tempDataCount = me.worldCount Then
      For i as Integer = 1 to me.worldCount
        prepareFunction = "setAmbiance#" & Format$(tempArray(i),"000")
        Call_IfExists prepareFunction(me.worldList(i).ambiance) to isSuccess
        if not isSuccess Then
          logger.wCrit("Function " & prepareFunction & " has an error or does not exists")
          logger.wCrit("Terminating execution... Please, press a key.")
          Waitkey
          stop
        Else
          logger.wInfo("World №" & i & " ambiance set to " & me.worldList(i).ambiance.gameZoneStyling)
          isSuccess = %FALSE
        endif
      Next
    Else
      logger.wCrit("$WORLDSSEQUENCE data count does not match %WORLDCOUNT.")
      logger.wCrit("Terminating execution... Please, press a key.")
      Waitkey
      stop
    EndIf
    
    tempDataCount = loadData($MINIMUMTOTALRIVERWIDTH, tempArray)
  
    if tempDataCount = me.worldCount Then
      for i as DWord = 1 to me.worldCount
          me.worldList(i).minimumTotalRiverWidth = tempArray(i)
          if me.worldList(i).minimumTotalRiverWidth < 3 * me.worldList(i).ambiance.riverArmsCount Then
          	logger.wCrit("$MINIMUMTOTALRIVERWIDTH for world №" & i & " is insufficient." )
          	logger.wCrit("Value is: " & me.worldList(i).minimumTotalRiverWidth & $Tab & "Minimal is: 3 * " & me.worldList(i).ambiance.riverArmsCount & " = " & Str$(3 * me.worldList(i).ambiance.riverArmsCount))
            logger.wCrit("Terminating execution... Please, press a key.")
            Waitkey
            stop
          End If
          if iseven(me.worldList(i).minimumTotalRiverWidth) then
          	incr me.worldList(i).minimumTotalRiverWidth
          End If
      Next
    Else
      logger.wCrit("$MINIMUMTOTALRIVERWIDTH data count does not match %WORLDCOUNT.")
      logger.wCrit("Terminating execution... Please, press a key.")
      Waitkey
      stop
    EndIf
    
    tempDataCount = loadData($WORLDLEVEL, tempArray)
    
    if tempDataCount = me.worldCount Then
      For i as Integer = 1 to me.worldCount
        if tempArray(i) = previousLevel or tempArray(i) = previousLevel + 1 Then
          if tempArray(i) = previousLevel + 1 and (me.worldList(i).ambiance.hidden <> %VISIBLE or me.worldList(i).ambiance.deadEnd <> %ONMAINSTREAM) Then
            logger.wCrit("First world of each level must be visible and on main stream.")
            logger.wCrit("Terminating execution... Please, press a key.")
          endif
          me.worldList(i).level = tempArray(i)
          previousLevel = tempArray(i)
        Else
          logger.wCrit("$WORLDLEVEL data must contain consecutive numbers.")
          logger.wCrit("Terminating execution... Please, press a key.")
          Waitkey
          stop
        endif
      next
    Else
      logger.wCrit("$WORLDLEVEL data count does not match %WORLDCOUNT.")
      logger.wCrit("Terminating execution... Please, press a key.")
      Waitkey
      stop
    EndIf
    
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
    logger.wInfo("Sucessfully registered " & me.worldCount & " worlds in " & previousLevel & " levels.")
    logger.write(%LT_ToConsole, "", "", %TAG_NOTAG)
  
#EndRegion

#Region "River properties"

  for i as Integer = 1 to me.worldCount
  
    
    If i < me.worldCount Then
      me.worldList(i).streamsOutCount = min(me.worldList(i+1).ambiance.riverArmsCount, me.worldList(i).ambiance.riverArmsCount)
    endif
    
    if me.worldList(i).ambiance.riverArmsCount = 1 then me.worldList(i).ambiance.riverArmWidthDistribution = %EQUAL
  
    select case me.worldList(i).ambiance.riverArmWidthDistribution
    
    	Case %EQUAL
    	
        if me.worldList(i).ambiance.riverArmsCount = 1 Then
          equalWidth = me.worldList(i).minimumTotalRiverWidth
        else
          equalWidth = 1 + 2 * Ceil(((me.worldList(i).minimumTotalRiverWidth - me.worldList(i).ambiance.riverArmsCount)/me.worldList(i).ambiance.riverArmsCount)/2)
        endif
        me.worldList(i).widestArmWidth = equalWidth
        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
          'Width
          me.worldList(i).arms(j).width = equalWidth
          'Random depth profile
          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
        Next
        
    	Case %SPLIT
        
        splitWidthValue1 = me.worldList(i).minimumTotalRiverWidth / max(me.worldList(i).ambiance.riverArmsCount, 3)
        splitWidthValue2 = (max(me.worldList(i).ambiance.riverArmsCount, 3) - 1) * splitWidthValue1
        splitArmValue1 = me.worldList(i).ambiance.riverArmsCount / 2
          
        if splitArmValue1 <> assign(ceil(splitArmValue1), splitArmValue2) then Decr splitArmValue1
        
        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
          'Width
          if splitArmValue1 > 2 and splitWidthValue1 >=8 then
            me.worldList(i).arms(j).width = 5
            splitWidthValue1 -= 5
            decr splitArmValue1
            me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
            Iterate for
          elseif splitArmValue1 > 0 and splitWidthValue1 >= 3 then
            me.worldList(i).arms(j).width = 3
            splitWidthValue1 -= 3
            decr splitArmValue1
            me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
            Iterate for
          endif
          
          splitArmValue1 = 0
          splitWidthValue2 += splitWidthValue1
          splitWidthValue1 = 0
            
          if splitArmValue2 = 1 Then
          	me.worldList(i).arms(j).width = 1 + 2 * ceil(splitWidthValue2 / 2)
          	me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
          	Iterate for
          Else
            me.worldList(i).arms(j).width = 1 + 2 * ceil((splitWidthValue2 - splitArmValue2) / splitArmValue2) / 2
          End If
          
          me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
          
          'Random depth profile
          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
        Next
        
    	Case %DISTRIBUTED
    	
    	distributedBase = (me.worldList(i).minimumTotalRiverWidth /(( me.worldList(i).ambiance.riverArmsCount + 1 ) / 2)) / me.worldList(i).ambiance.riverArmsCount
    	distributedTotal = 0

      for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
        'Width
        if j = me.worldList(i).ambiance.riverArmsCount Then
          me.worldList(i).arms(j).width += iseven(assign(me.worldList(i).minimumTotalRiverWidth - distributedTotal, me.worldList(i).arms(j).width))
        Else
          me.worldList(i).arms(j).width += iseven(assign(Round(distributedBase * j,0),me.worldList(i).arms(j).width))
          distributedTotal += me.worldList(i).arms(j).width
        endif
        
        me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
        
        'Random depth profile
        me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
      Next
        
    	Case %MOSTLYNARROW
    	
        narrowCount = 0
        narrowCurrent = 3
        narrowTotal = 0
        
        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
          incr narrowCount
          if narrowCount > 3 then
          	narrowCount = 0
          	narrowCurrent += 2
          End If
          'Width
          if j = me.worldList(i).ambiance.riverArmsCount Then
            me.worldList(i).arms(j).width += iseven(assign(me.worldList(i).minimumTotalRiverWidth - narrowTotal, me.worldList(i).arms(j).width))
          else
            me.worldList(i).arms(j).width = narrowCurrent
            narrowTotal += narrowCurrent
          endif
          
          me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
          
          'Random depth profile
          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
        Next
        
    	Case %MOSTLYWIDE
    	
        wideTotal = 0
        
        for j as integer = 1 to me.worldList(i).ambiance.riverArmsCount
          'Width
          if j = me.worldList(i).ambiance.riverArmsCount Then
            me.worldList(i).arms(j).width += iseven(assign(me.worldList(i).minimumTotalRiverWidth - wideTotal, me.worldList(i).arms(j).width))
          Else
            me.worldList(i).arms(j).width += iseven(assign(ceil(me.worldList(i).minimumTotalRiverWidth / (me.worldList(i).ambiance.riverArmsCount + j - 1)), me.worldList(i).arms(j).width))
            wideTotal += me.worldList(i).arms(j).width
          endif
          
          me.worldList(i).widestArmWidth = max(me.worldList(i).widestArmWidth, me.worldList(i).arms(j).width)
          
          'Random depth profile
          me.worldList(i).arms(j).depthProfile = getRandomFlag(me.worldList(i).ambiance.armsDepthProfiles)
        Next
        
    End Select
    
    '[todo] <Something to do here>
    ' Here sorting me.worldList(i).arms(j).width wide to narrow ; how array sort ?
    
  Next
  
#EndRegion

    
#Region "Map dimensioning"

    minimumWorldSideSize = 3 + 2 * %BANKSWIDTH
    
    for i as Integer = 1 to me.worldCount
      me.worldList(i).sizeInSquaresCount = minimumWorldSideSize * me.squareLimitsRatio * me.worldList(i).ambiance.relativeSizeWorld

'[t] be careful if more than a 'special' world per mainStream world or special world bigger than parent world
      if me.worldList(i).ambiance.hidden <> %VISIBLE or me.worldList(i).ambiance.deadEnd <> %ONMAINSTREAM then
        worldSizes(i) = me.worldList(i).sizeInSquaresCount + worldSizes(i-1)
      Else
        worldSizes(i) = me.worldList(i).sizeInSquaresCount
      EndIf

      if worldSizes(maxSizeIndex) <= worldSizes(i) Then
        maxSizeIndex = i
      endif
    Next
    
    mapCentreX = worldSizes(maxSizeIndex) + 1
    
    ' First world at left
    me.worldList(1).NWlimit.Y = 1
    me.worldList(1).SElimit.Y = me.worldList(1).sizeInSquaresCount
    bottomLeft = me.worldList(1).SElimit.Y
    
    me.worldList(1).SElimit.X = mapCentreX
    me.worldList(1).NWlimit.X = mapCentreX - me.worldList(1).sizeInSquaresCount
    
    for i as Integer = 2 to me.worldCount
      
      if me.worldList(i).ambiance.hidden <> %VISIBLE or me.worldList(i).ambiance.deadEnd <> %ONMAINSTREAM then
      '[todo] <Something to do here>
        
      Else
          if actualSide = %LEFTSIDE Then
            if bottomLeft > (bottomRight + 2 * %BANKSWIDTH + me.worldList(i-1).widestArmWidth)) then
              actualSide = %RIGHTSIDE
            End If
          Else
            if bottomRight > (bottomLeft + 2 * %BANKSWIDTH + me.worldList(i-1).widestArmWidth)) then
              actualSide = %LEFTSIDE
            End If
          endif
          
          select case actualSide
          	Case %LEFTSIDE
              me.worldList(i).NWlimit.Y = bottomLeft + 1
              me.worldList(i).SElimit.Y = bottomLeft + me.worldList(i).sizeInSquaresCount
              bottomLeft = me.worldList(i).SElimit.Y
              me.worldList(i).SElimit.X = mapCentreX
              me.worldList(i).NWlimit.X = mapCentreX - me.worldList(i).sizeInSquaresCount
          	Case %RIGHTSIDE
              me.worldList(i).NWlimit.Y = bottomRight + 1
              me.worldList(i).SElimit.Y = bottomRight + me.worldList(i).sizeInSquaresCount
              bottomRight = me.worldList(1).SElimit.Y
              me.worldList(i).SElimit.X = mapCentreX + 1 + me.worldList(i).sizeInSquaresCount
              me.worldList(i).NWlimit.X = mapCentreX + 1
          End Select

      End If
    	
    Next
    
    mapDimensions.X = 2 * worldSizes(maxSizeIndex) + 1
    mapDimensions.Y = max(bottomRight, bottomLeft)
    
    Global map(mapDimensions.X,mapDimensions.Y) as tBtbGameZone
    
#Endregion

  
  End Function
end Type



function loadData(sourceString as String, byref storeArray() as dword)
'Local ndata as DWord = PARSECOUNT(sourceString, "")
'redim storeArray(ndata)
  Return Parse(sourceString, storeArray,",")
End Function

Function TBMain()

  logger.defaultTitle = Function_Name
  logger.wInfo("Logger loaded")

  call parametersSetting ' Sets initial variables
  Call initDisplay ' Create the windows for map display
  Call initWorldMap ' Build straight river
  Call stirWorldMap
  CAll sleepDisplay ' Final loop to keep displaying map

End Function

function parametersSetting()

  logger.defaultTitle = Function_Name

  global displayWindowSize as tXY
  global hWnd AS DWORD
  
  Randomize(%RNDSEED)
  
  Global mapDimensions as TXY
  Global displayWindowSize as tXY
  
  Global btbuniverse as tBtbuniverse

  'For overlay ?
  'Global btblevel as tBtblevel
  Global btbworld as tBtbworld

End Function

Function initWorldMap()

  for i = 1 to btbuniverse.worldCount
    ' set streamStart and streamStop for each arm
  Next
  
End Function

function initDisplay()

  DESKTOP GET CLIENT TO displayWindowSize.x, displayWindowSize.y

  MsgBox 0, str$(displayWindowSize.x) & " x " & str$(displayWindowSize.y),,"Desktop resolution"

  int32 posX   = -15 + displayWindowSize.x - min(mapDimensions.x, displayWindowSize.x / 2)
  int32 posY   = 0
  int32 width  = mapDimensions.x' min(mapDimensions.x, displayWindowSize.x / 2)
  int32 height = mapDimensions.y' min(mapDimensions.y, displayWindowSize.y) + 100

  hWnd = Canvas_Window("press ESC to quit", posX, posY, width, height)
  Canvas_Attach(hWnd, 0, True)

End Function

Function bitCount(storage as Long) as Long
  Return Tally(bin$(Storage), "1")
End Function

function isFlagSet(storage as long, flag as long) as long
  return bit_get(storage, log2(flag))
end function

function getFlag(id as Dword, storage as Long)
  dim i as Long = -1
  do
    incr i
    if isFlagSet(storage, pow(2,i)) Then
      decr id
    endif
  loop while id > 0
  Return Pow(2,i)
End Function

Function getRandomFlag(storage as Long)
  Local randomValue as Long = RND(1,bitCount(storage))
  Return getFlag(randomValue, storage)
End Function
