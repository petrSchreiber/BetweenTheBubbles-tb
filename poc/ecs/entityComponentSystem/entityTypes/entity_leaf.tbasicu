#include once "entity_baseTypes.tbasicu"

uses "math"

type tEntity_Leaf extends tEntityBase
  physicsable    as tPhysicsBase
  collidable     as tBoundingCircle
  renderable     as tRenderBase
 
  function Initialize()
    me.typeName        = remain$(typeof(me), ".") ' Cuts the udt. start
    me.entityAbility   = %ECS_RENDERABLE | %ECS_PHYSICSABLE | %ECS_COLLIDABLE

    me.collidable.Initialize(1)   ' Radius
    me.collidable.bounciness = 3
    
    me.physicsable.Initialize(1)    ' Mass
    
    me.renderable.funcRender = me.typeName + "_Render"
  End Function

end type

function tEntity_Leaf_Render(entityPtr as dword)
  dim leaf as tEntity_Leaf at entityPtr

  tbgl_pushColor 0, 255, 0
        
    int32 i
    tbgl_beginPoly %TBGL_POLYGON
      tbgl_vertex 0, 0
      
      for i = 1 to 16
        tbgl_vertex cos(degtorad(360/16*i))*leaf.collidable.radius, sin(degtorad(360/16*i))*leaf.collidable.radius
      next
      
      tbgl_vertex 0, 0
    tbgl_endPoly

  tbgl_popColor

'  tbgl_pushState %TBGL_TEXTURING | %TBGL_ALPHA
'  
'    tbgl_pushAlphaFunc %TBGL_GREATER, 0.5
'    tbgl_pushTexture leaf.renderable.texture(1)
'    tbgl_pushColor 255, 255, 255
'          
'      int32 i
'      tbgl_beginPoly %TBGL_QUADS
'        tbgl_texCoord2d 0, 0 : tbgl_vertex -leaf.collidable.radius, -leaf.collidable.radius
'        tbgl_texCoord2d 1, 0 : tbgl_vertex  leaf.collidable.radius, -leaf.collidable.radius
'        tbgl_texCoord2d 1, 1 : tbgl_vertex  leaf.collidable.radius,  leaf.collidable.radius
'        tbgl_texCoord2d 0, 1 : tbgl_vertex -leaf.collidable.radius,  leaf.collidable.radius
'      tbgl_endPoly
'
'    tbgl_popColor
'    tbgl_popTexture
'    tbgl_popAlphaFunc
'  
'  tbgl_popState
end function
