uses "math"

#include once "entity_baseTypes.tbasicu"


type tEntity_ForceArea_Circular
  tEntity_ForceArea_Base
  
  radius            as Float32
  centralIntensity  as float32 ' 0..1
  borderIntensity   as float32 ' 0..1
  
  debugable         as tDebugBase
  
  function Initialize(force as float32, radius as float32, centralIntensity as float32, borderIntensity as float32)
    me.areaType         = %ECS_FORCEAREA_CIRCULAR
    me.typeName         = remain$(typeof(me), ".") ' Cuts the udt. start
    me.entityAbility    = %ECS_DEBUGABLE | %ECS_FORCEAREA
    me.baseForce        = force
    
    me.radius           = radius
    me.centralIntensity = centralIntensity
    me.borderIntensity  = borderIntensity
    
    me.debugable.funcDebugRender = me.typeName + "_DebugRender"
  End Function
  
  function GetForceContribution(distance as float32, byref out_x as float32, byref out_y as float32)
    float32 normalizedDistance = distance / me.radius
    float32 forceGiven = lerp2(normalizedDistance, me.baseForce * me.centralIntensity, me.baseForce * me.borderIntensity)
    
    out_x = cos(DegToRad(me.rotation)) * forceGiven
    out_y = sin(DegToRad(me.rotation)) * forceGiven
  end function


end type

function tEntity_ForceArea_Circular_DebugRender(entityPtr as dword)

  dim forceArea as tEntity_ForceArea_Circular at entityPtr
  
  tbgl_pushpolygonLook %GL_LINE
    tbgl_nGon(0, 0, forceArea.Radius, 36)
  tbgl_popPolygonLook

  ' "arrow"
  tbgl_beginPoly %TBGL_LINES
    tbgl_vertex -forceArea.radius * 0.75, 0
    tbgl_vertex  forceArea.radius * 0.75, 0

    tbgl_vertex  forceArea.radius * 0.75, 0
    tbgl_vertex  forceArea.radius * 0.55, forceArea.radius * 0.20

    tbgl_vertex  forceArea.radius * 0.75, 0
    tbgl_vertex  forceArea.radius * 0.55,-forceArea.radius * 0.20
  tbgl_endPoly
end function
