uses "console"

begin const
  %ECS_FORCEAREA   = 1
  %ECS_COLLIDABLE  = 2
  %ECS_PHYSICSABLE = 4
  %ECS_RENDERABLE  = 8
  %ECS_DEBUGABLE   = 16
  
  %ECS_FORCEAREA_INDEX   = log2(%ECS_FORCEAREA)
  %ECS_COLLIDABLE_INDEX  = log2(%ECS_COLLIDABLE)
  %ECS_PHYSICSABLE_INDEX = log2(%ECS_PHYSICSABLE)
  %ECS_RENDERABLE_INDEX  = log2(%ECS_RENDERABLE)
  %ECS_DEBUGABLE_INDEX   = log2(%ECS_DEBUGABLE)
end const

#include "entityList/entityList_forcearea.tbasicu"
#include "entityList/entityList_collidable.tbasicu"
#include "entityList/entityList_physicsable.tbasicu"
#include "entityList/entityList_renderable.tbasicu"
#include "entityList/entityList_debugable.tbasicu"

type tEntityComponentSystem
  ' List to store all entities (so we can check if it was added already)
  entityPtrs()    as dword
  entityPtrsCount as dword

  ' Specialized lists
  forcearea   as tEntityList_Forcearea
  collidable  as tEntityList_Collidable
  physicsable as tEntityList_Physicsable
  renderable  as tEntityList_Renderable
  debugable   as tEntityList_Debugable
  
  function _Create()
  	redim me.entityPtrs(1)
  	me.forcearea.setPhysicsable(varptr(me.physicsable))
  	me.collidable.setPhysicsable(varptr(me.physicsable))
  	
  	' Set last elements for first frame
    int32 i
    dim entityBase as tEntityBase at 0
    for i = 1 to me.entityPtrsCount
      setAt(entityBase, me.entityPtrs(i))
      entityBase.position.lastX = entityBase.position.x
      entityBase.position.lastY = entityBase.position.y
    next
  End Function
  
  '
  
  function AddEntityPtr(entityPtr as dword)
    printl entityPtr in 12
    
    #region "input validation"
    ' Is pointer valid
    if entityPtr = 0 then
      msgbox 0, "tEntityComponentSystem.AddEntityPtr: passed pointer is null"
      stop
    end if
  
    ' Is pointer pointer to Entity (starts with self describing name)
    dim entityBase as tEntityBase at entityPtr
    
    if not Type_Exists(entityBase.typeName) then
      msgbox 0, "tEntityComponentSystem.AddEntityPtr: passed pointer does not lead to existing entity type"
      stop
    end if
    
    int32 entityCapacity = ubound(me.entityPtrs)
    
    ' Is pointer new?
    if me.entityPtrsCount > 0 then
      dim entityPtrs(me.entityPtrsCount) as dword at varptr(me.entityPtrs(1)) ' Hack because me.array are not supported in array scan
      int32 indexOfEntity = array scan entityPtrs(), = entityPtr
      if indexOfEntity > 0 then
        msgbox 0, "tEntityComponentSystem.AddEntityPtr: passed entity pointer already present"
        stop
      end if
    end If
    #endregion

    #region "taking note of added entity"
    me.entityPtrsCount += 1

    if me.entityPtrsCount > entityCapacity then
      redim preserve me.entityPtrs(entityCapacity * 2)
    end if
    
    me.entityPtrs(me.entityPtrsCount) = entityPtr
    #endregion
    
    #region "add the entity to all suitable use-oriented lists"
    
    ' First, let's recreate the entity TYPE for ability queries
    dim entity like entityBase.typeName at entityPtr
    dim entityDescriptor as tEntityList_Descriptor at 0
    dim entityDescriptorPtr as dword

    if entity.hasAbility(%ECS_FORCEAREA) then
      printl entityBase.typeName + " is forcearea"
      me.forcearea.addEntityPtr(entityPtr)
    end if

    if entity.hasAbility(%ECS_COLLIDABLE) then
      printl entityBase.typeName + " is collidable"
      entityDescriptorPtr = me.collidable.addEntityPtr(entityPtr)

      SetAt(entityDescriptor, entityDescriptorPtr)
      entityDescriptor.pAbility(%ECS_COLLIDABLE_INDEX) = entityPtr+UDT_ElementOffset(entity.collider.typeName)
      if entity.hasAbility(%ECS_PHYSICSABLE) then
        entityDescriptor.pAbility(%ECS_PHYSICSABLE_INDEX) = entityPtr+UDT_ElementOffset(entity.physics.mass)
      end if
    end if

    if entity.hasAbility(%ECS_PHYSICSABLE) then
      printl entityBase.typeName + " is physicsable"
      entityDescriptorPtr = me.physicsable.addEntityPtr(entityPtr)

      SetAt(entityDescriptor, entityDescriptorPtr)
      entityDescriptor.pAbility(%ECS_PHYSICSABLE_INDEX) = entityPtr+UDT_ElementOffset(entity.physics.mass)
    end if

    if entity.hasAbility(%ECS_RENDERABLE) then
      printl entityBase.typeName + " is renderable"
      me.renderable.addEntityPtr(entityPtr)
    end if

    if entity.hasAbility(%ECS_DEBUGABLE) then
      printl entityBase.typeName + " is debugable"
      me.debugable.addEntityPtr(entityPtr)
    end if
    #endregion
    
  end function
  
  function ProcessEntities(frameRate as float32)
    if me.forcearea.count   then me.forcearea.Process()
    if me.collidable.count  then me.collidable.Process()
    if me.physicsable.count then me.physicsable.Process(frameRate)
    if me.renderable.count  then me.renderable.Process()
    if me.debugable.count   then me.debugable.Process()

    ' Automatically update last frame data
    int32 i
    dim entityBase as tEntityBase at 0
    for i = 1 to me.entityPtrsCount
      setAt(entityBase, me.entityPtrs(i))
      entityBase.position.lastX = entityBase.position.x
      entityBase.position.lastY = entityBase.position.y
    next
  end function

end type
