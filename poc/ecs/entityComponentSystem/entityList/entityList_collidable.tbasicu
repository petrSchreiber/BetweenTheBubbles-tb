#include once "entityList_base.tbasicu"

type tEntityList_Collidable
  tEntityList
  
  physicsablePtr  as dword
  
  function SetPhysicsable(physicsablePtr as dword)
    me.physicsablePtr = physicsablePtr
  end function
  
  function Process()
    if me.physicsablePtr = 0 then exit function
    if me.count < 2          then exit function ' It needs at least 2 to collide :)
    
    dim collidablePtr(me.count) as tEntityList_Descriptor at me.pData
    
    dim dummyPhysicsable as tEntityList at me.physicsablePtr
    dim pointersToPhysicsable(dummyPhysicsable.count) as tEntityList_Descriptor at peek(dword, me.physicsablePtr) ' Retrieving pData

    dim entityBase    as tEntityBase at 0
    dim entityPhysics as tPhysicsBase at 0
    
    dim forceAreaBase as tEntity_ForceArea_Base at 0
    dim forceAreaCircularEntity as tEntity_ForceArea_Circular at 0
    
    ' IDEA:
    ' For 4 colliders, C = 4
    ' 
    ' Collision table (Y = Yes, collide with each other, N = Don't collide)
    ' We want to calculate interaction with 1 and 2 for example, but doing the same for 2 and 1 makes no sense
    '
    '   1 2 3 4
    ' 1 N N N N
    ' 2 Y N N N
    ' 3 Y Y N N
    ' 4 Y Y Y N
    '
    ' Now, expanded to just indexes (again for 4 colliders)
    '
    ' A B
    ' 1 2
    ' 1 3
    ' 1 4
    ' 2 3
    ' 2 4
    ' 3 4
    '
    ' Aha! We can see a pattern here:
    ' Column A goes from 1x for (C-1) to (C-1)x for 1
    ' Column B goes from C to C, C-1, to C, C-1, C-2 ...
    ' The number of pairs can be calculated like ((C-1) / 2) * (C)
    
    int32 minColliderBIndex = 2                       ' Starting at 2 for any count, will raise to count
    int32 maxColliderBIndex = me.count                ' Ending at count

    int32 indexOfColliderA = 1                        ' Basically 1 always :)
    int32 indexOfColliderB = minColliderBIndex        ' Basically 2 always :)
    
    int32 pairCount = ((me.count-1) / 2) * (me.count) ' For 4 it is 6, for 5 it is 10, ...
    
    int32 auxiliaryCounter
    int32 auxiliaryCounterMax = me.count - 1          ' Example: 3 for case of 4, as seen in the table, then it will go down with each A increment
    
    printl "Potential collision interactions: " + pairCount in 13
    
    int32 i
    float32 dx, dy, distance, intersection

    dim entityA as tEntityBase at 0
    dim entityB as tEntityBase at 0
    
    dim circleColliderA as tBoundingCircle at 0
    dim circleColliderB as tBoundingCircle at 0

    dim physicsA as tPhysicsBase at 0
    dim physicsB as tPhysicsBase at 0
    dword physicsAPtr, physicsBPtr
    float32 speedX, speedY, spin
    
    for i = 1 to pairCount
      'printl indexOfColliderA, indexOfColliderB   ' UNCOMMENT TO SEE THE TABLE

      ' -- Calculating collision between collider A and collider B
      '[todo] Detect collider type, prepare safe check for collider type (now we just presume circular for all)
      
      #region "circle to circle collision"
      ' -- Getting the info about position from base interface
      SetAt(entityA, collidablePtr(indexOfColliderA).pEntity)
      SetAt(entityB, collidablePtr(indexOfColliderB).pEntity)

      dx = entityB.position.x - entityA.position.x
      dy = entityB.position.y - entityA.position.y
      distance = sqr(dx*dx + dy*dy)
      
      ' -- Getting the info about radius/bounciness from collidable interface
      SetAt(circleColliderA, collidablePtr(indexOfColliderA).pAbility(%ECS_COLLIDABLE_INDEX))
      SetAt(circleColliderB, collidablePtr(indexOfColliderB).pAbility(%ECS_COLLIDABLE_INDEX))
      
      intersection = (circleColliderA.radius + circleColliderB.radius) - distance
      
      if intersection > 0 then ' The circles overlap = collide
        ' Fix the distance to "just touch" = move circles away on the vector dx, dy, but each in opposite direction
        entityA.position.x -= dx/distance * intersection/2
        entityA.position.y -= dy/distance * intersection/2
        
        entityB.position.x += dx/distance * intersection/2
        entityB.position.y += dy/distance * intersection/2
        
        ' -- Physics
        speedX = (entityA.position.x-entityA.position.lastX) - (entityB.position.x-entityB.position.lastX)
        speedY = (entityA.position.y-entityA.position.lastY) - (entityB.position.Y-entityB.position.lastY)
        
        if abs(speedX) > abs(speedY) then
          spin = sgn(speedX) * iif(entityA.position.y > entityB.position.y, 1, -1)
        else
          spin = sgn(speedY) * iif(entityA.position.x > entityB.position.x, -1, 1)
        end if
        spin*= sqr(speedX*speedX + speedY*speedY) * 30
        
        physicsAPtr = collidablePtr(indexOfColliderA).pAbility(%ECS_PHYSICSABLE_INDEX)
        if physicsAPtr then
          if circleColliderA.bounciness > 0 then
            Setat(physicsA, physicsAPtr)
            physicsA.force.x += -(dx/distance * intersection/2) * circleColliderA.bounciness
            physicsA.force.y += -(dy/distance * intersection/2) * circleColliderA.bounciness
            physicsA.spin    += spin
          end if
        end if
      
        physicsBPtr = collidablePtr(indexOfColliderB).pAbility(%ECS_PHYSICSABLE_INDEX)
        if physicsBPtr then
          if circleColliderB.bounciness > 0 then
            Setat(physicsB, physicsBPtr)
            physicsB.force.x += (dx/distance * intersection/2) * circleColliderB.bounciness
            physicsB.force.y += (dy/distance * intersection/2) * circleColliderB.bounciness
            physicsB.spin    += -spin
          end if
        end if
        
      end if
      
      #endregion
      
      ' -- Calculating next indexOfColliderA, indexOfColliderB
      auxiliaryCounter += 1
      if auxiliaryCounter = auxiliaryCounterMax then
        indexOfColliderA += 1
        
        minColliderBIndex += 1
        
        auxiliaryCounter     = 0
        auxiliaryCounterMax -= 1
      end if
      
      indexOfColliderB = CYCLE_Next(indexOfColliderB, minColliderBIndex, maxColliderBIndex)
    next

  end function
end type

