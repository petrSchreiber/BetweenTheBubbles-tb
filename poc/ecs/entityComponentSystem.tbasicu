uses "console"

#include once "entityBaseTypes.tbasicu"

begin const
  %ECS_RENDERABLE  = 1
  %ECS_PHYSICSABLE = 2
  %ECS_COLLIDABLE  = 4
  %ECS_FORCEABLE   = 8
  %ECS_DEBUGABLE   = 16
end const

type tEntityDescriptor
  pEntity       as dword
  abilityOffset as dword
end Type

type tEntityList
  pData     as dword
  capacity  as dWord
  count     as dword
  
  function AddEntityPtr(pEntity as dword, optional offsetAble as dword = 0)

    me.count += 1
    
    if me.count > me.capacity then
      me.capacity = me.count * 2
      
      if me.pData = 0 then
        me.pData = HEAP_alloc(sizeof(tEntityDescriptor) * me.capacity)
      else
        me.pData = HEAP_realloc(me.pData, sizeof(tEntityDescriptor) * me.capacity)
      end if

    end if
    
    dim pointers(me.count) as tEntityDescriptor at me.pData

    pointers(me.count).pEntity       = pEntity
    pointers(me.count).abilityOffset = offsetAble
    
  end function
  
  function _Destroy()
  	if me.pData then HEAP_Free(me.pData)
  End Function

end type

type tRenderableEntityList
  tEntityList
  
  function Process()
  
    if me.count = 0 then exit function
    
    dim pointers(me.count) as tEntityDescriptor at me.pData
    dim entityBase as tEntityBase at 0
    
    int32 i
    for i = 1 to me.count
      SetAt(entityBase, pointers(i).pEntity)
      
      tbgl_pushMatrix
        tbgl_translate entityBase.position.x, entityBase.position.y
        tbgl_rotate entityBase.rotation
        
        call entityBase.typeName + "_Render"(pointers(i).pEntity)
      tbgl_popMatrix

    next
  end function
end type

type tDebugableEntityList
  tEntityList
  
  function Process()
  
    if me.count = 0 then exit function
    
    dim pointers(me.count) as tEntityDescriptor at me.pData
    dim entityBase as tEntityBase at 0
    
    int32 i
    for i = 1 to me.count
      SetAt(entityBase, pointers(i).pEntity)
      
      tbgl_pushMatrix
        tbgl_translate entityBase.position.x, entityBase.position.y
        tbgl_rotate entityBase.rotation
        
        call entityBase.typeName + "_DebugRender"(pointers(i).pEntity)
      tbgl_popMatrix

    next
    
  end function
end type

type tForceableEntityList
  tEntityList
  
  physicsablePtr  as dword
  
  function SetPhysicsable(physicsablePtr as dword)
    me.physicsablePtr = physicsablePtr
  end function
  
  function Process()
    if me.physicsablePtr = 0 then exit function
    if me.count = 0 then exit function
    
    dim pointers(me.count) as tEntityDescriptor at me.pData
    
    dim dummyPhysicsable as tEntityList at me.physicsablePtr
    dim pointersToPhysicsable(dummyPhysicsable.count) as tEntityDescriptor at peek(dword, me.physicsablePtr) ' Retrieving pData

    dim entityBase    as tEntityBase at 0
    dim entityPhysics as tPhysicsBase at 0
    
    dim forceAreaBase as tForceAreaBaseEntity at 0
    dim forceAreaCircularEntity as tForceAreaCircularEntity at 0
    
    int32 i, j
    float32 distance, fx, fy
    for i = 1 to me.count
      SetAt(forceAreaBase, pointers(i).pEntity)
      
      if forceAreaBase.areaType = %TFORCEAREATYPE_CIRCULAR then
        setAt(forceAreaCircularEntity, pointers(i).pEntity)
        
        for j = 1 to dummyPhysicsable.count
          setAt(entityBase, pointersToPhysicsable(j).pEntity)
          setAt(entityPhysics, pointersToPhysicsable(j).pEntity+pointersToPhysicsable(j).abilityOffset)
          
          distance = dist(entityBase.position.x, entityBase.position.y, forceAreaBase.position.x, forceAreaBase.position.y)
          if distance < forceAreaCircularEntity.radius then
           
            forceAreaCircularEntity.GetForceContribution(distance, fx, fy)
            entityPhysics.force.x += fx
            entityPhysics.force.y += fy
          end if
        next
      else
        msgbox 0, "Unknown ForceAbleEntity"
        stop
      end if
     
    next
  end function
end type

type tPhysicsableEntityList
  tEntityList
  
  function Process(frameRate as float32)
    if me.count = 0 then exit function
    
    dim dummyPhysicsable as tEntityList at me.pData
    dim pointersToPhysicsable(dummyPhysicsable.count) as tEntityDescriptor at me.pData ' Retrieving pData

    dim entityBase    as tEntityBase at 0
    dim entityPhysics as tPhysicsBase at 0
    
    int32 i
    for i = 1 to me.count
      setAt(entityBase, pointersToPhysicsable(i).pEntity)
      setAt(entityPhysics, pointersToPhysicsable(i).pEntity+pointersToPhysicsable(i).abilityOffset)
      
      entityBase.position.x += (entityPhysics.force.x / entityPhysics.mass) / frameRate
      entityBase.position.y += (entityPhysics.force.y / entityPhysics.mass) / frameRate
      
      entityPhysics.force.x = 0'sqr(entityPhysics.force.x)
      entityPhysics.force.y = 0'sqr(entityPhysics.force.y)
    next
    
  end function
end type

type tEntityComponentSystem

  renderable  as tRenderableEntityList
  debugable   as tDebugableEntityList
  forceAble   as tForceableEntityList
  physicsable as tPhysicsableEntityList
  collidable  as tEntityList

  ' Total overview
  entityPtrs()    as dword
  entityPtrsCount as dword
  

  function _Create()
  	redim me.entityPtrs(1)
  	me.forceAble.setPhysicsable(varptr(me.physicsable))
  End Function
  
  '
  
  function AddEntityPtr(entityPtr as dword)
    printl entityPtr in 12
  
    ' Is pointer valid
    if entityPtr = 0 then
      msgbox 0, "tEntityComponentSystem.AddEntityPtr: passed pointer is null"
      stop
    end if
  
    ' Is pointer pointer to Entity (starts with self describing name)
    dim entityBase as tEntityBase at entityPtr
    
    if not Type_Exists(entityBase.typeName) then
      msgbox 0, "tEntityComponentSystem.AddEntityPtr: passed pointer does not lead to existing entity type"
      stop
    end if
    
    int32 entityCapacity = ubound(me.entityPtrs)
    
    ' Is pointer new?
    if me.entityPtrsCount > 0 then
      dim entityPtrs(me.entityPtrsCount) as dword at varptr(me.entityPtrs(1)) ' Hack because me.array are not supported in array scan
      int32 indexOfEntity = array scan entityPtrs(), = entityPtr
      if indexOfEntity > 0 then
        msgbox 0, "tEntityComponentSystem.AddEntityPtr: passed entity pointer already present"
        stop
      end if
    end If
        
    me.entityPtrsCount += 1

    if me.entityPtrsCount > entityCapacity then
      redim preserve me.entityPtrs(entityCapacity * 2)
    end if
    
    me.entityPtrs(me.entityPtrsCount) = entityPtr
    
    ' Add it to the correct list(s)
    
    ' First, let's recreate the entity TYPE for member queries
    dim entity like entityBase.typeName at entityPtr
    
    if entity.hasAbility(%ECS_RENDERABLE) then
      printl entityBase.typeName + " is renderable"
      me.renderable.addEntityPtr(entityPtr)
    end if
        
    if entity.hasAbility(%ECS_PHYSICSABLE) then
      printl entityBase.typeName + " is physicsable"
      me.physicsable.addEntityPtr(entityPtr, UDT_ElementOffset(entity.physics.mass))
    end if

    if entity.hasAbility(%ECS_COLLIDABLE) then
      printl entityBase.typeName + " is collidable"
      me.collidable.addEntityPtr(entityPtr)
    end if

    if entity.hasAbility(%ECS_DEBUGABLE) then
      printl entityBase.typeName + " is debugable"
      me.debugable.addEntityPtr(entityPtr)
    end if

    if entity.hasAbility(%ECS_FORCEABLE) then
      printl entityBase.typeName + " is forceable"
      me.forceable.addEntityPtr(entityPtr)
    end if
    
  end function
  
  function ProcessEntities(frameRate as float32)
  
    if me.forceable.count then me.forceable.Process()
    if me.physicsable.count then me.physicsable.Process(frameRate)
    if me.renderable.count then me.renderable.Process()
    if me.debugable.count then me.debugable.Process()
  end function

end type
