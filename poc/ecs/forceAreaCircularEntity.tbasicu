uses "math"

#include once "entityBaseTypes.tbasicu"


type tForceAreaCircularEntity
  tForceAreaBaseEntity
  
  radius            as Float32
  centralIntensity  as float32 ' 0..1
  borderIntensity   as float32 ' 0..1
  
  function Initialize(force as float32, radius as float32, centralIntensity as float32, borderIntensity as float32)
    me.areaType         = %TFORCEAREATYPE_CIRCULAR
    me.typeName         = remain$(typeof$(me), ".") ' Cuts the udt. start
    me.entityAbility    = %ECS_DEBUGABLE | %ECS_FORCEABLE
    me.baseForce        = force
    
    me.radius           = radius
    me.centralIntensity = centralIntensity
    me.borderIntensity  = borderIntensity
  End Function
  
  function GetForceContribution(distance as float32, byref out_x as float32, byref out_y as float32)
    float32 normalizedDistance = distance / me.radius
    float32 forceGiven = lerp2(normalizedDistance, me.baseForce * me.centralIntensity, me.baseForce * me.borderIntensity)
    
    out_x = cos(DegToRad(me.rotation)) * forceGiven
    out_y = sin(DegToRad(me.rotation)) * forceGiven
  end function
end type

function tForceAreaCircularEntity_DebugRender(entityPtr as dword)
  dim forceCircular as tForceAreaCircularEntity at entityPtr

  tbgl_pushpolygonLook %GL_LINE
    tbgl_nGon(0, 0, forceCircular.Radius, 36)
  tbgl_popPolygonLook

  ' "arrow"
  tbgl_beginPoly %TBGL_LINES
    tbgl_vertex -forceCircular.radius * 0.75, 0
    tbgl_vertex  forceCircular.radius * 0.75, 0

    tbgl_vertex  forceCircular.radius * 0.75, 0
    tbgl_vertex  forceCircular.radius * 0.55, forceCircular.radius * 0.20

    tbgl_vertex  forceCircular.radius * 0.75, 0
    tbgl_vertex  forceCircular.radius * 0.55,-forceCircular.radius * 0.20
  tbgl_endPoly
end function
