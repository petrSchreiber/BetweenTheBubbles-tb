Uses "Biff"

#include once "logger_ps.tbasicu"

%DIFFICULTY_MONITOR_RATE = 0.5 's
%DIFFICULTY_STORE_RATE = 2 ' s (averaging)

Type monitorData
  temps as Double
  difficulty as Double
  meanFrameRate as dword
  meanDistance as Double
  meanCapacity as double
end type


Type difficultyMonitor

  contextPtr as dword
  logger as LoggerPS
  difficulty as double
  oldTime as Double ' to calculate time diff between two calls
  tempsMonitor as double
  tempsStore as Double
  rateCount as DWord
  '[t] can't use undimensioned array conjointly with " Local context as GameContext at me.contextPtr "
  storage(200000) as monitorData
  mesuresCount as DWord
  oneData as monitorData
  gamesessionStartTime as double
  
  function Prepare(contextPtr as dword)

    me.contextPtr = contextPtr
    Local context as GameContext at me.contextPtr

    #if %LOGGERPS
      me.logger.initialize("difficultyMonitor")
    #endif
    
    me.gamesessionStartTime = context.gameTime
    
    redim me.storage(10)
    me.mesuresCount = 0
  
  end function
  
  Function Close()
  
    Local context as GameContext at me.contextPtr
    Local currentTime as double = context.gameTime
  
    me.Store(currentTime)
    me.exportToFile
    Redim me.storage(1)
    
  end function

  
  Function Rate()
  
    LOCAL x, y, z, distance, difficulty, capacity, counter AS Double
    Local context as GameContext at me.contextPtr
    Local totalDistance, totalCapacity as Double
    
    tbgl_entityGetPos(uScreenGame.player.scene,uScreenGame.player.entity,x,y,z,%TRUE) 'Absolute Player position
    
    for i as integer = 1 to uScreenGame.bubbleDirector.bubbleTotalCount
      capacity = uScreenGame.bubbleDirector.bubble(i).capacity ' Bubble capacity
      if capacity = 0 then iterate for
      incr counter
      distance = tbgl_entityGetDistancePos(uScreenGame.player.scene,uScreenGame.bubbleDirector.bubble(i).entity,x,y,z) ' Bubble---Player Distance
      totalDistance += distance
      totalCapacity += capacity
      me.oneData.difficulty += POW3(1/capacity) * POW2(distance) ' One far big bubble is easier to catch than many close little ones 
    next
    
    me.oneData.meanFrameRate += context.framerate
    me.oneData.meandistance += totalDistance / counter
    me.oneData.meanCapacity += totalCapacity / counter
    counter = 0 
  end function
  
  Function Monitor()
'[breakpoint] <Any note here. Breakpoint will be set to line following this statement>
'[t] on second pass me.contextPtr is lost (reset to 0 , why ? I think it's because storage() was redim. )
    Local context as GameContext at me.contextPtr
    Local currentTime as double = context.gameTime
    
    if me.oldTime = 0 Then 'First pass
      me.tempsMonitor = 0
      me.tempsStore = 0
    Else
      me.tempsMonitor += currentTime - me.oldTime
      me.tempsStore += currentTime - me.oldTime
    end if
    
    if me.tempsMonitor >= %DIFFICULTY_MONITOR_RATE Then
      me.Rate
      incr me.rateCount
      me.tempsMonitor = 0
    EndIf
    
    if me.tempsStore >= %DIFFICULTY_MONITOR_RATE Then
      me.Store(currentTime)
      me.tempsStore = 0
      me.rateCount = 0
    EndIf
    
    me.oldTime = currentTime
    
  end function


  Function Store(currentTime as double)
    if not me.rateCount > 0 then return
    incr me.mesuresCount
    Local toStore as monitorData
    if me.mesuresCount > ubound(me.storage) Then
      Decr me.mesuresCount
      me.ExportToFile
      me.mesuresCount = 1
    endif
    toStore.temps = currentTime - me.gamesessionStartTime
    toStore.difficulty = me.oneData.difficulty / me.rateCount
    toStore.meanCapacity = me.oneData.meanCapacity / me.rateCount
    toStore.meanDistance = me.oneData.meanDistance / me.rateCount
    toStore.meanFrameRate = me.oneData.meanframeRate / me.rateCount
    
    me.storage(me.mesuresCount) = toStore
    
    me.oneData.difficulty = 0
    me.oneData.meanCapacity = 0
    me.oneData.meanDistance =0
    me.oneData.meanframeRate = 0
    
    '[t] Shame, following syntax does not work.
    'me.storage(me.mesuresCount).temps = currentTime
    'me.storage(me.mesuresCount).difficulty = me.difficulty / me.rateCount
    
    me.rateCount = 0
  end function
  
  Function ExportToFile()
    If Not me.mesuresCount > 0 then Return
    Local OutFile as String
    Local toWrite as monitorData
    
    OutFile = APP_ScriptPath & remove$(DateTime$,":") & ".xls"
    BIFF_CreateFile(OutFile)
    BIFF_WriteText("Time(s)",1,1)
    BIFF_WriteText("FrameRate",1,2)
    BIFF_WriteText("Mean capacity",1,3)
    BIFF_WriteText("Mean distance",1,4)
    BIFF_WriteText("Difficulty",1,5)
    for i as dword = 1 to me.mesuresCount
      toWrite = me.Storage(i)
      BIFF_WriteNumber(toWrite.temps,1+i,1) ' Time
      BIFF_WriteNumber(toWrite.meanFrameRate,1+i,2) ' FrameRate
      BIFF_WriteNumber(toWrite.meanCapacity,1+i,3) ' Capacity
      BIFF_WriteNumber(toWrite.meanDistance,1+i,4) ' Distance
      BIFF_WriteNumber(toWrite.difficulty,1+i,5) ' Difficulty
    next
    BIFF_CloseFile 
  end function
  
end type